# Phase: Single-Container Bootstrap & Multi-Container Expansion

This document defines the plan for a **single distributable Docker image** that can run as one container (demo/simple case) and **expands to multiple containers** based on config. The **primary path is multi-container**: users specify in **initial config** that an install will have Primary + DB + LLM agent (and optionally workers). The system deploys the primary container, reads config, sees desired services are not yet deployed, and **deploys them immediately**. Later, the user may enable workers (or more services) via the **config manager**; the system deploys those containers. Single-container is explicitly for **demo or initial bootstrap only**—not the typical long-term state.

References: `docs/AGENTIC_OVERVIEW.md` Phase 10, `docs/ARCHITECTURE.md`, `memory.md` § Standard Implementation Process.

## Design emphasis: multi-container expansion

- **Single container** is for demo or the brief period before expansion. The average user is **not** expected to stay on a single container except during a demo.
- **Testing and plan must fully cover expanding to multiple containers**: initial config specifying Primary + DB + Agent (and optionally workers), bootstrap flow that auto-deploys missing services on first run, and later expansion (e.g. enabling workers via config manager).
- **Initial config**: User (or installer) can specify in `app_config.yaml` (or equivalent) that the install should have Primary, DB, and LLM agent. That config may be provided before the first container starts (e.g. mounted volume or generated by an entrypoint).
- **Bootstrap flow**: (1) Deploy the single primary container. (2) Primary starts, loads config. (3) If config says `features.db_enabled` and/or `features.agent_enabled` (and optionally `features.workers_enabled`) but those services are **not yet deployed**, the system **immediately** runs Ansible (or equivalent) to deploy DB, agent (+ ollama), and/or workers. (4) Primary may need to restart or reconnect after DB/agent are up (e.g. switch storage to MongoDB, enable agent trigger).
- **Later expansion**: User changes config via Config Manager (e.g. enables workers, or adds more workers). System detects config change, sees new desired services or count, and deploys the new container(s). Same mechanism as bootstrap, triggered by config change instead of first boot.

## Goals

- **One image, one initial container**: Single Docker image; first run is one container (primary) with flatfile storage and local executor.
- **Config-driven expansion**: Initial config can specify Primary + DB + Agent (and optionally workers). System deploys primary, then **immediately** deploys any requested but missing services. Later, config manager changes (e.g. enable workers) trigger deployment of additional containers.
- **Config**: Text (YAML) for edit/review; API for view/change; config backup/restore and data backup/restore (separate).
- **Distributable image**: Build from repo; users run one container, provide or edit config, and get Primary + DB + Agent (and optionally workers) deployed automatically.
- **Tests**: Must cover **all expansion scenarios**: single (demo), Primary+DB, Primary+Agent, Primary+DB+Agent, Primary+DB+Agent+Workers, and transitions (e.g. add DB, add agent, add workers later). See [Test matrix](#test-matrix) below.

## Stages (each with unit/validation tests and docs)

**Test requirements for all stages:** Unit tests must cover new code including edge cases and invalid data. Validation tests must use at least API-level checks (e.g. HTTP client) and must verify **outcomes** where feasible (e.g. after config restore, re-read config and assert content; after data restore, assert storage state), not only that an action returned 200. The plan includes at least basic validation of web functions (e.g. GET `/config` returns 200 and deployment section is available via API). See `tests/TEST_COVERAGE_AUDIT.md` and `tests/README.md`.

### Stage 1: Config framework ✅
- **Config file**: `app_config.yaml` in `CONFIG_DIR` (default `/app/config`). Schema: `storage`, `agent`, `cluster`, `features` (db_enabled, agent_enabled, workers_enabled), `deployment` (placeholders: agent_host, db_host, worker_hosts for future).
- **Loader**: `web/config_manager.py`; config wins when key present.
- **API**: `GET /api/config`, `PUT /api/config` (validate + save), `GET /api/config/backup`, `POST /api/config/restore`.
- **Storage init**: `web/storage/__init__.py` uses config when `app_config.yaml` exists.
- **Tests**: `tests/test_config_manager.py` (unit), `tests/test_config_api.py` (API; require Flask/venv).

### Stage 2: Single-container image (demo / bootstrap entry point) ✅
- **Dockerfile**: Unchanged as “all-in-one” (web + Ansible); default env: `STORAGE_BACKEND=flatfile`, no `depends_on` for mongodb/agent/workers.
- **Compose**: `docker-compose.single.yml` — runs only `ansible-web`; used for **demo** or as the **initial container** before bootstrap expands to multi-container. Not the long-term target for typical users.
- **Validation**: `scripts/validate_single_container.py`; `docs/REBUILD.md` § Single-container mode. **Tests**: `tests/test_deployment_single.py`.

### Stage 3: Config panel UI and data backup/restore ✅
- **Config panel**: New page (or section) to view/edit key options, backup config, restore config. Quick-config for most-used options.
- **Data backup**: API + UI to backup data (flatfile: archive config dir; MongoDB: mongodump or documented procedure). Separate from config backup.
- **Data restore**: `POST /api/data/restore` (flatfile); UI on Config page. **Tests**: `tests/test_data_backup_restore.py`; docs: API.md, CONFIGURATION.md.

### Stage 4: Ansible-driven deployment and bootstrap flow
- **Playbooks**: Deploy MongoDB container, agent stack (agent + ollama), worker container(s). Config (`features.*`, `deployment.*`) drives which playbooks run and where (variables for future remote hosts).
- **Bootstrap on start**: On primary startup, after loading config, if `features.db_enabled` / `features.agent_enabled` / `features.workers_enabled` are true but the corresponding services are **not yet present** (e.g. no MongoDB container, no agent container), run the appropriate Ansible playbooks **immediately** to deploy them. Then reconnect (e.g. storage to MongoDB, agent URL) or document restart if needed.
- **Config-change trigger**: When user updates config via Config Manager (e.g. enables workers or increases worker count), system detects **desired state** (from config) vs **current state** (what is actually deployed/reachable) and runs deployment for the delta (e.g. deploy new workers only). Implementation must track or detect “what is deployed” (e.g. MongoDB reachable, agent health OK, worker count) so we do not redeploy unnecessarily and so bootstrap knows what is missing.
- **Integration**: Config panel exposes feature toggles and (when implemented) triggers deployment; API may expose “deploy now” or deployment status. Framework must support both bootstrap-on-start and config-change-triggered deployment.
- **Tests**: Must cover bootstrap flow (primary starts with config requesting DB+Agent → DB and Agent get deployed) and later expansion (enable workers via config → workers deployed). See [Test matrix](#test-matrix).

### Stage 5: Build procedure and distributable image ✅
- **Build**: `docker build -t ansible-simpleweb:latest .` from repo root. Documented in `docs/REBUILD.md` § Building the distributable image.
- **Docs**: `docs/REBUILD.md` covers: run single container (demo); provide initial config for Primary+DB+Agent; how bootstrap deploys missing services; add workers later via config manager; backup/restore config and data. README Quick Start points to REBUILD for single-image/demo.
- **Tests**: Smoke test = run single container then `python3 scripts/validate_single_container.py`. Bootstrap-with-config (DB+Agent deployed on first start) is manual or via full compose; see test matrix (Stage 6 / T6).

### Stage 6: Deployment and system-size tests (multi-container focus) ✅
- **Deployment tests**: `tests/test_deployment_matrix.py` covers the [Test matrix](#test-matrix) T1–T9. Real integration tests against a running primary (`PRIMARY_URL`). T1 (single): flatfile, config, deployment status, playbooks. T2–T5: topology-specific checks (MongoDB, agent, workers). T6–T9: deployment status/run API and Config page; full bootstrap/expand documented for manual validation.
- **System-size tests**: For each topology, validate basic functions (health, run playbook, storage type, agent review when agent enabled, workers when workers enabled). Transitions: after “add workers” via config, verify workers register and can run jobs.
- **How to run**: Start primary, then `PRIMARY_URL=http://localhost:3001 pytest tests/test_deployment_matrix.py -v`. Topology tests skip unless the running system matches. Full bootstrap/expand (T6–T9) can be run manually per scenarios table.
- **Remote hosts**: Config and playbook variables support `agent_host`, `db_host`, `worker_hosts`; tests run with local hosts first; remote-host execution is future work.

## Scenarios and variations (must be covered)

Implementation and testing **must** handle these explicitly:

| Scenario | Description | Implementation / test |
|----------|-------------|------------------------|
| **Demo / single** | User runs one container only (e.g. quick demo). No DB, no agent, no workers. | Single-container compose; health and run playbook; flatfile storage. |
| **Initial: Primary + DB + Agent** | Initial config specifies `features.db_enabled: true`, `features.agent_enabled: true`. User deploys primary container (e.g. with config mounted). | Primary starts → loads config → sees DB and Agent requested but not deployed → **immediately** runs playbooks to deploy MongoDB and agent+ollama → primary uses MongoDB and triggers agent. |
| **Initial: Primary + DB only** | Config has only `db_enabled: true`. | Bootstrap deploys MongoDB only; primary switches to MongoDB storage. |
| **Initial: Primary + Agent only** | Config has only `agent_enabled: true`. | Bootstrap deploys agent + ollama only; primary triggers agent on job completion. |
| **Initial: Primary + DB + Agent + Workers** | Config has db, agent, and `workers_enabled: true` (and optionally worker count/hosts). | Bootstrap deploys DB, agent stack, and worker container(s). |
| **Later: add DB** | Started as single or Primary+Agent; user enables DB via config manager. | System deploys MongoDB; primary reconnects to MongoDB (may require restart or dynamic switch). |
| **Later: add Agent** | Started as single or Primary+DB; user enables Agent via config manager. | System deploys agent + ollama; primary starts triggering agent. |
| **Later: add Workers** | Started as Primary (or +DB, +Agent); user enables workers via config manager. | System deploys worker container(s); workers register; jobs can be routed to workers. |
| **Later: add more Workers** | Already have workers; user increases count or adds hosts. | System deploys additional worker container(s). |

**Detection of “not yet deployed”**: Primary must be able to tell that a requested feature (DB, agent, workers) is not yet deployed (e.g. no MongoDB reachable, no agent health endpoint, no workers registered). Bootstrap and config-change logic use this to decide what to deploy.

## Test matrix

Testing **must** cover the following. Each row is a topology or transition to verify.

| Id | Topology / scenario | What to verify |
|----|---------------------|----------------|
| T1 | **Single (demo)** | One container; flatfile; local executor; playbook runs; no agent, no workers. |
| T2 | **Primary + DB** | MongoDB deployed (bootstrap or pre-existing); primary uses MongoDB storage; schedules/inventory persist. |
| T3 | **Primary + Agent** | Agent + ollama deployed; primary triggers agent on job completion; review appears in UI. |
| T4 | **Primary + DB + Agent** | Both DB and agent deployed and used; storage is MongoDB; agent reviews work. |
| T5 | **Primary + DB + Agent + Workers** | Workers deployed and registered; jobs can be routed to workers; sync and execution work. |
| T6 | **Bootstrap: config requests DB+Agent on first start** | Primary starts with config `db_enabled: true`, `agent_enabled: true`; before bootstrap no DB/agent; after bootstrap DB and agent are up and primary uses them. |
| T7 | **Expand: add workers via config** | Start with Primary+DB+Agent; change config to enable workers; deployment runs; workers appear and accept jobs. |
| T8 | **Expand: add DB later** | Start Primary only (or +Agent); enable DB via config; MongoDB deployed; primary uses MongoDB. |
| T9 | **Expand: add Agent later** | Start Primary only (or +DB); enable Agent via config; agent+ollama deployed; triggers work. |

Additional transitions (add agent when DB already present, add DB when agent present, etc.) should be covered by the same mechanism; at least one “add later” for each of DB, Agent, Workers is required.

## Config schema (Stage 1)

```yaml
# app_config.yaml (defaults; all optional)
storage:
  backend: flatfile   # flatfile | mongodb
  mongodb:
    host: mongodb
    port: 27017
    database: ansible_simpleweb

agent:
  enabled: false
  trigger_enabled: true
  model: qwen2.5-coder:3b

cluster:
  mode: standalone   # standalone | primary
  registration_token: ""
  checkin_interval: 60
  local_worker_tags: ["local"]

features:
  db_enabled: false
  agent_enabled: false
  workers_enabled: false

# For future: deploy services on remote hosts
deployment:
  agent_host: local
  db_host: local
  worker_hosts: []   # list of hostnames
```

## Out of scope (this phase)

- Full GUI modernization (left nav, top tabs, modular pages).
- Authentication (users/groups, SSL, ACLs).
- Actual remote-host deployment execution (only config and variable wiring).

## Branch and process

- **Branch**: `feat/single-container-bootstrap`
- **Process**: Per `memory.md` § Standard Implementation Process (plan, tests, docs, atomic commits, memory updates). Subagents where parallel; reviewer with loop limit.
