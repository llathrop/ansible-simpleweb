<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Log - {{ playbook }} | Ansible Web Interface</title>
    <link rel="stylesheet" href="/static/css/base.css">
    <script>
        // Immediately apply cached theme to prevent flash of unstyled content
        (function() {
            try {
                var cached = localStorage.getItem('ansible-web-theme-vars');
                if (cached) {
                    var vars = JSON.parse(cached);
                    var root = document.documentElement;
                    for (var key in vars) {
                        if (vars[key]) root.style.setProperty(key, vars[key]);
                    }
                }
            } catch (e) {}
        })();
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.6.0/socket.io.min.js"></script>
    <script src="/static/js/theme.js"></script>
    <style>
        /* Page-specific overrides for live log full-screen view */
        body {
            padding: 0;
        }
    </style>
</head>
<body class="live-log-page">
    <div class="header">
        <div class="header-left">
            <h1>{{ playbook.replace('-', ' ').title() }}</h1>
            <div class="header-info">
                <span>Target: <strong>{{ target }}</strong></span>
                <span>Worker: <strong>{{ worker_name or 'local-executor' }}</strong></span>
                <span>Log: <strong>{{ log_file }}</strong></span>
            </div>
            <span id="statusBadge" class="status-badge status-{{ status }}">{{ status }}</span>
        </div>
        <div class="header-right">
            <div class="connection-status">
                <span class="connection-dot" id="connectionDot"></span>
                <span id="connectionText">Connecting...</span>
            </div>
            <div class="controls">
                <button id="scrollToggle" class="btn btn-toggle">Auto-scroll ON</button>
                <button id="clearBtn" class="btn btn-secondary">Clear</button>
            </div>
            <div class="theme-selector">
                <label for="themeSelect">Theme:</label>
                <select id="themeSelect" class="theme-select"></select>
            </div>
            <a href="/" class="btn btn-primary">Back to Dashboard</a>
        </div>
    </div>

    <div class="log-container" id="logContainer">
        <div class="log-content" id="logContent"></div>
    </div>

    <div class="footer-bar">
        <span>Run ID: {{ run_id }}</span>
        <span id="lineCount">0 lines</span>
    </div>

    <script>
        const runId = "{{ run_id }}";
        const logContent = document.getElementById('logContent');
        const logContainer = document.getElementById('logContainer');
        const statusBadge = document.getElementById('statusBadge');
        const connectionDot = document.getElementById('connectionDot');
        const connectionText = document.getElementById('connectionText');
        const scrollToggle = document.getElementById('scrollToggle');
        const clearBtn = document.getElementById('clearBtn');
        const lineCountEl = document.getElementById('lineCount');

        let autoScroll = true;
        let lineCount = 0;

        // Connect to WebSocket
        const socket = io();

        socket.on('connect', function() {
            connectionDot.classList.add('connected');
            connectionDot.classList.remove('disconnected');
            connectionText.textContent = 'Connected';

            // Join the run's room
            socket.emit('join_run', { run_id: runId });
        });

        socket.on('disconnect', function() {
            connectionDot.classList.remove('connected');
            connectionDot.classList.add('disconnected');
            connectionText.textContent = 'Disconnected';
        });

        // Receive catch-up content when joining
        socket.on('log_catchup', function(data) {
            if (data.run_id === runId && data.content) {
                logContent.innerHTML = '';
                lineCount = 0;
                appendLogContent(data.content);
                updateStatus(data.status);
            }
        });

        // Receive new log lines
        socket.on('log_line', function(data) {
            if (data.run_id === runId) {
                appendLogLine(data.line);
            }
        });

        // Playbook finished
        socket.on('playbook_finished', function(data) {
            if (data.run_id === runId) {
                updateStatus(data.status);
            }
        });

        // Playbook error
        socket.on('playbook_error', function(data) {
            if (data.run_id === runId) {
                appendLogLine('\n=== ERROR: ' + data.error + ' ===\n');
                updateStatus('failed');
            }
        });

        function appendLogContent(content) {
            const lines = content.split('\n');
            lines.forEach(line => {
                if (line) {
                    appendLogLine(line + '\n');
                }
            });
        }

        function appendLogLine(line) {
            const lineEl = document.createElement('div');
            lineEl.className = 'log-line ' + getLineClass(line);
            lineEl.textContent = line;
            logContent.appendChild(lineEl);
            lineCount++;
            lineCountEl.textContent = lineCount + ' lines';

            if (autoScroll) {
                logContainer.scrollTop = logContainer.scrollHeight;
            }
        }

        function getLineClass(line) {
            const lowerLine = line.toLowerCase();
            if (lowerLine.includes('ok:')) return 'ok';
            if (lowerLine.includes('changed:')) return 'changed';
            if (lowerLine.includes('failed:') || lowerLine.includes('fatal:')) return 'failed';
            if (lowerLine.includes('skipping:')) return 'skipping';
            if (lowerLine.startsWith('task [') || lowerLine.startsWith('TASK [')) return 'task';
            if (lowerLine.startsWith('play [') || lowerLine.startsWith('PLAY [')) return 'play';
            if (lowerLine.includes('play recap') || lowerLine.includes('PLAY RECAP')) return 'recap';
            return '';
        }

        function updateStatus(status) {
            statusBadge.textContent = status;
            statusBadge.className = 'status-badge status-' + status;
        }

        // Toggle auto-scroll
        scrollToggle.addEventListener('click', function() {
            autoScroll = !autoScroll;
            scrollToggle.textContent = autoScroll ? 'Auto-scroll ON' : 'Auto-scroll OFF';
            scrollToggle.classList.toggle('paused', !autoScroll);

            if (autoScroll) {
                logContainer.scrollTop = logContainer.scrollHeight;
            }
        });

        // Clear log display (doesn't affect actual log file)
        clearBtn.addEventListener('click', function() {
            logContent.innerHTML = '';
            lineCount = 0;
            lineCountEl.textContent = '0 lines';
        });

        // Pause auto-scroll when user scrolls up
        logContainer.addEventListener('scroll', function() {
            const isAtBottom = logContainer.scrollHeight - logContainer.scrollTop <= logContainer.clientHeight + 50;
            if (!isAtBottom && autoScroll) {
                autoScroll = false;
                scrollToggle.textContent = 'Auto-scroll OFF';
                scrollToggle.classList.add('paused');
            }
        });
    </script>
</body>
</html>
